// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: agent_assignments.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAgentAssignment = `-- name: CreateAgentAssignment :one
INSERT INTO agent_assignments (
    user_id, agent_id_reference, allocation_strategy, priority, max_concurrent_requests
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, agent_id_reference, allocation_strategy, priority, max_concurrent_requests, created_at, updated_at
`

type CreateAgentAssignmentParams struct {
	UserID                pgtype.UUID `json:"user_id"`
	AgentIDReference      string      `json:"agent_id_reference"`
	AllocationStrategy    string      `json:"allocation_strategy"`
	Priority              int32       `json:"priority"`
	MaxConcurrentRequests int32       `json:"max_concurrent_requests"`
}

func (q *Queries) CreateAgentAssignment(ctx context.Context, arg CreateAgentAssignmentParams) (AgentAssignment, error) {
	row := q.db.QueryRow(ctx, createAgentAssignment,
		arg.UserID,
		arg.AgentIDReference,
		arg.AllocationStrategy,
		arg.Priority,
		arg.MaxConcurrentRequests,
	)
	var i AgentAssignment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AgentIDReference,
		&i.AllocationStrategy,
		&i.Priority,
		&i.MaxConcurrentRequests,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAgentAssignment = `-- name: DeleteAgentAssignment :exec
DELETE FROM agent_assignments
WHERE id = $1
`

func (q *Queries) DeleteAgentAssignment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAgentAssignment, id)
	return err
}

const deleteAgentAssignmentByUserAndAgent = `-- name: DeleteAgentAssignmentByUserAndAgent :exec
DELETE FROM agent_assignments
WHERE user_id = $1 AND agent_id_reference = $2
`

type DeleteAgentAssignmentByUserAndAgentParams struct {
	UserID           pgtype.UUID `json:"user_id"`
	AgentIDReference string      `json:"agent_id_reference"`
}

func (q *Queries) DeleteAgentAssignmentByUserAndAgent(ctx context.Context, arg DeleteAgentAssignmentByUserAndAgentParams) error {
	_, err := q.db.Exec(ctx, deleteAgentAssignmentByUserAndAgent, arg.UserID, arg.AgentIDReference)
	return err
}

const getAgentAssignmentByID = `-- name: GetAgentAssignmentByID :one
SELECT id, user_id, agent_id_reference, allocation_strategy, priority, max_concurrent_requests, created_at, updated_at FROM agent_assignments
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAgentAssignmentByID(ctx context.Context, id pgtype.UUID) (AgentAssignment, error) {
	row := q.db.QueryRow(ctx, getAgentAssignmentByID, id)
	var i AgentAssignment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AgentIDReference,
		&i.AllocationStrategy,
		&i.Priority,
		&i.MaxConcurrentRequests,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAgentAssignmentsByAgentID = `-- name: GetAgentAssignmentsByAgentID :many
SELECT id, user_id, agent_id_reference, allocation_strategy, priority, max_concurrent_requests, created_at, updated_at FROM agent_assignments
WHERE agent_id_reference = $1
`

func (q *Queries) GetAgentAssignmentsByAgentID(ctx context.Context, agentIDReference string) ([]AgentAssignment, error) {
	rows, err := q.db.Query(ctx, getAgentAssignmentsByAgentID, agentIDReference)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AgentAssignment{}
	for rows.Next() {
		var i AgentAssignment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AgentIDReference,
			&i.AllocationStrategy,
			&i.Priority,
			&i.MaxConcurrentRequests,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAgentAssignmentsByUserID = `-- name: GetAgentAssignmentsByUserID :many
SELECT id, user_id, agent_id_reference, allocation_strategy, priority, max_concurrent_requests, created_at, updated_at FROM agent_assignments
WHERE user_id = $1
ORDER BY priority DESC
`

func (q *Queries) GetAgentAssignmentsByUserID(ctx context.Context, userID pgtype.UUID) ([]AgentAssignment, error) {
	rows, err := q.db.Query(ctx, getAgentAssignmentsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AgentAssignment{}
	for rows.Next() {
		var i AgentAssignment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AgentIDReference,
			&i.AllocationStrategy,
			&i.Priority,
			&i.MaxConcurrentRequests,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
