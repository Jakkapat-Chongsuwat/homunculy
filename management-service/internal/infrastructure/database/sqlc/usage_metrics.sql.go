// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage_metrics.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUsageMetric = `-- name: CreateUsageMetric :one
INSERT INTO usage_metrics (user_id, agent_id_reference, tokens_used, requests_count, cost)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, agent_id_reference, tokens_used, requests_count, cost, timestamp
`

type CreateUsageMetricParams struct {
	UserID           pgtype.UUID    `json:"user_id"`
	AgentIDReference string         `json:"agent_id_reference"`
	TokensUsed       int64          `json:"tokens_used"`
	RequestsCount    int64          `json:"requests_count"`
	Cost             pgtype.Numeric `json:"cost"`
}

func (q *Queries) CreateUsageMetric(ctx context.Context, arg CreateUsageMetricParams) (UsageMetric, error) {
	row := q.db.QueryRow(ctx, createUsageMetric,
		arg.UserID,
		arg.AgentIDReference,
		arg.TokensUsed,
		arg.RequestsCount,
		arg.Cost,
	)
	var i UsageMetric
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AgentIDReference,
		&i.TokensUsed,
		&i.RequestsCount,
		&i.Cost,
		&i.Timestamp,
	)
	return i, err
}

const getTotalUsageByUser = `-- name: GetTotalUsageByUser :one
SELECT
    user_id,
    SUM(tokens_used) as total_tokens_used,
    SUM(requests_count) as total_requests_count,
    SUM(cost) as total_cost
FROM usage_metrics
WHERE user_id = $1
GROUP BY user_id
`

type GetTotalUsageByUserRow struct {
	UserID             pgtype.UUID `json:"user_id"`
	TotalTokensUsed    int64       `json:"total_tokens_used"`
	TotalRequestsCount int64       `json:"total_requests_count"`
	TotalCost          int64       `json:"total_cost"`
}

func (q *Queries) GetTotalUsageByUser(ctx context.Context, userID pgtype.UUID) (GetTotalUsageByUserRow, error) {
	row := q.db.QueryRow(ctx, getTotalUsageByUser, userID)
	var i GetTotalUsageByUserRow
	err := row.Scan(
		&i.UserID,
		&i.TotalTokensUsed,
		&i.TotalRequestsCount,
		&i.TotalCost,
	)
	return i, err
}

const getUsageMetricsByUserID = `-- name: GetUsageMetricsByUserID :many
SELECT id, user_id, agent_id_reference, tokens_used, requests_count, cost, timestamp FROM usage_metrics
WHERE user_id = $1
ORDER BY timestamp DESC
LIMIT $2
`

type GetUsageMetricsByUserIDParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
}

func (q *Queries) GetUsageMetricsByUserID(ctx context.Context, arg GetUsageMetricsByUserIDParams) ([]UsageMetric, error) {
	rows, err := q.db.Query(ctx, getUsageMetricsByUserID, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageMetric{}
	for rows.Next() {
		var i UsageMetric
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AgentIDReference,
			&i.TokensUsed,
			&i.RequestsCount,
			&i.Cost,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsageMetricsByUserIDAndDateRange = `-- name: GetUsageMetricsByUserIDAndDateRange :many
SELECT id, user_id, agent_id_reference, tokens_used, requests_count, cost, timestamp FROM usage_metrics
WHERE user_id = $1
  AND timestamp >= $2
  AND timestamp <= $3
ORDER BY timestamp DESC
`

type GetUsageMetricsByUserIDAndDateRangeParams struct {
	UserID      pgtype.UUID      `json:"user_id"`
	Timestamp   pgtype.Timestamp `json:"timestamp"`
	Timestamp_2 pgtype.Timestamp `json:"timestamp_2"`
}

func (q *Queries) GetUsageMetricsByUserIDAndDateRange(ctx context.Context, arg GetUsageMetricsByUserIDAndDateRangeParams) ([]UsageMetric, error) {
	rows, err := q.db.Query(ctx, getUsageMetricsByUserIDAndDateRange, arg.UserID, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageMetric{}
	for rows.Next() {
		var i UsageMetric
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AgentIDReference,
			&i.TokensUsed,
			&i.RequestsCount,
			&i.Cost,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
