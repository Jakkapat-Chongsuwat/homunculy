// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quotas.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createQuota = `-- name: CreateQuota :one
INSERT INTO quotas (
    user_id, tier, max_agents, max_tokens_per_day, max_requests_per_day,
    max_requests_per_minute, used_tokens_today, used_requests_today, reset_date
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, user_id, tier, max_agents, max_tokens_per_day, max_requests_per_day, max_requests_per_minute, used_tokens_today, used_requests_today, reset_date, created_at, updated_at
`

type CreateQuotaParams struct {
	UserID               pgtype.UUID      `json:"user_id"`
	Tier                 string           `json:"tier"`
	MaxAgents            int32            `json:"max_agents"`
	MaxTokensPerDay      int64            `json:"max_tokens_per_day"`
	MaxRequestsPerDay    int32            `json:"max_requests_per_day"`
	MaxRequestsPerMinute int32            `json:"max_requests_per_minute"`
	UsedTokensToday      int32            `json:"used_tokens_today"`
	UsedRequestsToday    int32            `json:"used_requests_today"`
	ResetDate            pgtype.Timestamp `json:"reset_date"`
}

func (q *Queries) CreateQuota(ctx context.Context, arg CreateQuotaParams) (Quota, error) {
	row := q.db.QueryRow(ctx, createQuota,
		arg.UserID,
		arg.Tier,
		arg.MaxAgents,
		arg.MaxTokensPerDay,
		arg.MaxRequestsPerDay,
		arg.MaxRequestsPerMinute,
		arg.UsedTokensToday,
		arg.UsedRequestsToday,
		arg.ResetDate,
	)
	var i Quota
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Tier,
		&i.MaxAgents,
		&i.MaxTokensPerDay,
		&i.MaxRequestsPerDay,
		&i.MaxRequestsPerMinute,
		&i.UsedTokensToday,
		&i.UsedRequestsToday,
		&i.ResetDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteQuota = `-- name: DeleteQuota :exec
DELETE FROM quotas
WHERE user_id = $1
`

func (q *Queries) DeleteQuota(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuota, userID)
	return err
}

const getQuotaByUserID = `-- name: GetQuotaByUserID :one
SELECT id, user_id, tier, max_agents, max_tokens_per_day, max_requests_per_day, max_requests_per_minute, used_tokens_today, used_requests_today, reset_date, created_at, updated_at FROM quotas
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetQuotaByUserID(ctx context.Context, userID pgtype.UUID) (Quota, error) {
	row := q.db.QueryRow(ctx, getQuotaByUserID, userID)
	var i Quota
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Tier,
		&i.MaxAgents,
		&i.MaxTokensPerDay,
		&i.MaxRequestsPerDay,
		&i.MaxRequestsPerMinute,
		&i.UsedTokensToday,
		&i.UsedRequestsToday,
		&i.ResetDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resetDailyQuota = `-- name: ResetDailyQuota :exec
UPDATE quotas
SET used_tokens_today = 0, used_requests_today = 0, reset_date = $1
WHERE reset_date < CURRENT_TIMESTAMP
`

func (q *Queries) ResetDailyQuota(ctx context.Context, resetDate pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, resetDailyQuota, resetDate)
	return err
}

const updateQuota = `-- name: UpdateQuota :one
UPDATE quotas
SET used_tokens_today = $2, used_requests_today = $3, updated_at = CURRENT_TIMESTAMP
WHERE user_id = $1
RETURNING id, user_id, tier, max_agents, max_tokens_per_day, max_requests_per_day, max_requests_per_minute, used_tokens_today, used_requests_today, reset_date, created_at, updated_at
`

type UpdateQuotaParams struct {
	UserID            pgtype.UUID `json:"user_id"`
	UsedTokensToday   int32       `json:"used_tokens_today"`
	UsedRequestsToday int32       `json:"used_requests_today"`
}

func (q *Queries) UpdateQuota(ctx context.Context, arg UpdateQuotaParams) (Quota, error) {
	row := q.db.QueryRow(ctx, updateQuota, arg.UserID, arg.UsedTokensToday, arg.UsedRequestsToday)
	var i Quota
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Tier,
		&i.MaxAgents,
		&i.MaxTokensPerDay,
		&i.MaxRequestsPerDay,
		&i.MaxRequestsPerMinute,
		&i.UsedTokensToday,
		&i.UsedRequestsToday,
		&i.ResetDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
