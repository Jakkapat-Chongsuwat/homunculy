"""
Response building utilities for LangGraph agent service.

Handles AgentResponse construction and TTS audio generation.
"""

import base64
from typing import Any, Dict, Optional

from common.logger import get_logger
from settings.tts import tts_settings

from internal.domain.entities import AgentConfiguration, AgentResponse, AgentStatus
from internal.domain.services import TTSService

logger = get_logger(__name__)


class ResponseBuilder:
    """Builds AgentResponse instances with optional TTS audio."""

    def __init__(
        self,
        tts_service: Optional[TTSService] = None,
        storage_type: str = "memory",
    ) -> None:
        self._tts = tts_service
        self._storage_type = storage_type

    def update_storage_type(self, storage_type: str) -> None:
        self._storage_type = storage_type

    def build_success(
        self,
        configuration: AgentConfiguration,
        thread_id: str,
        response_text: str,
        summary_used: bool,
        checkpointer_name: str,
        audio_response: Optional[Dict[str, Any]] = None,
    ) -> AgentResponse:
        """Build successful response with metadata."""
        metadata = self._build_metadata(
            configuration, thread_id, summary_used, checkpointer_name, audio_response
        )
        return AgentResponse(
            message=response_text,
            confidence=0.95,
            reasoning=f"Generated by {configuration.model_name} via LangGraph",
            metadata=metadata,
            status=AgentStatus.COMPLETED,
        )

    def build_error(self, error_message: str) -> AgentResponse:
        """Build error response."""
        return AgentResponse(
            message=f"Error: {error_message}",
            confidence=0.0,
            reasoning="Failed to communicate with LLM via LangGraph",
            metadata={"error": error_message},
            status=AgentStatus.ERROR,
        )

    def _build_metadata(
        self,
        configuration: AgentConfiguration,
        thread_id: str,
        summary_used: bool,
        checkpointer_name: str,
        audio_response: Optional[Dict[str, Any]],
    ) -> Dict[str, Any]:
        metadata = {
            "model_used": configuration.model_name,
            "thread_id": thread_id,
            "storage_type": self._storage_type,
            "temperature": configuration.temperature,
            "max_tokens": configuration.max_tokens,
            "orchestrator": "langgraph",
            "summary_used": summary_used,
            "checkpointer": checkpointer_name,
        }
        if audio_response:
            metadata["audio"] = audio_response
        return metadata

    async def generate_audio(self, text: str) -> Optional[Dict[str, Any]]:
        """Generate TTS audio for response text."""
        if not self._tts:
            return None

        clean_text = self._clean_text_for_tts(text)
        if not clean_text or len(clean_text) < 3:
            return None

        try:
            return await self._synthesize_audio(clean_text)
        except Exception as e:
            logger.error("TTS generation failed", error=str(e))
            return None

    def _clean_text_for_tts(self, text: str) -> str:
        return text.replace("Called tool:", "").replace("text_to_speech", "").strip()

    async def _synthesize_audio(self, text: str) -> Dict[str, Any]:
        if not self._tts:
            raise ValueError("TTS service not configured")

        logger.info("Generating TTS audio", text_length=len(text))
        voice_id = tts_settings.default_voice_id

        audio_bytes = await self._tts.synthesize(
            text=text,
            voice_id=voice_id,
            model_id=tts_settings.elevenlabs_model_id,
            stability=tts_settings.default_stability,
            similarity_boost=tts_settings.default_similarity_boost,
            style=tts_settings.default_style,
            use_speaker_boost=tts_settings.default_use_speaker_boost,
        )

        return {
            "data": base64.b64encode(audio_bytes).decode("utf-8"),
            "format": "mp3",
            "encoding": "base64",
            "size_bytes": len(audio_bytes),
            "voice_id": voice_id,
        }


def create_response_builder(
    tts_service: Optional[TTSService] = None,
    storage_type: str = "memory",
) -> ResponseBuilder:
    """Factory function for ResponseBuilder."""
    return ResponseBuilder(tts_service=tts_service, storage_type=storage_type)
